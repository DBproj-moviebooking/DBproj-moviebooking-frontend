{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.compiler = compiler;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _lodash = require('lodash.get');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _unified = require('unified');\n\nvar _unified2 = _interopRequireDefault(_unified);\n\nvar _remarkParse = require('remark-parse');\n\nvar _remarkParse2 = _interopRequireDefault(_remarkParse);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _toArray(arr) {\n  return Array.isArray(arr) ? arr : Array.from(arr);\n}\n\nvar BLOCK_ELEMENT_TAGS = ['article', 'header', 'aside', 'hgroup', 'blockquote', 'hr', 'iframe', 'body', 'li', 'map', 'button', 'object', 'canvas', 'ol', 'caption', 'output', 'col', 'p', 'colgroup', 'pre', 'dd', 'progress', 'div', 'section', 'dl', 'table', 'td', 'dt', 'tbody', 'embed', 'textarea', 'fieldset', 'tfoot', 'figcaption', 'th', 'figure', 'thead', 'footer', 'tr', 'form', 'ul', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'video', 'script', 'style'];\nvar BLOCK_ELEMENT_REGEX = new RegExp('^<(' + BLOCK_ELEMENT_TAGS.join('|') + ')', 'i'); // [0] === tag, [...] = attribute pairs\n\nvar HTML_EXTRACTOR_REGEX = /([-A-Za-z0-9_]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|([^>\\s]+)))?/g;\nvar SELF_CLOSING_ELEMENT_TAGS = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\nvar SELF_CLOSING_ELEMENT_REGEX = new RegExp('^<(' + SELF_CLOSING_ELEMENT_TAGS.join('|') + ')', 'i');\nvar TEXT_AST_TYPES = ['text', 'textNode'];\nvar ATTRIBUTE_TO_JSX_PROP_MAP = {\n  'accept-charset': 'acceptCharset',\n  'accesskey': 'accessKey',\n  'allowfullscreen': 'allowFullScreen',\n  'allowtransparency': 'allowTransparency',\n  'autocomplete': 'autoComplete',\n  'autofocus': 'autoFocus',\n  'autoplay': 'autoPlay',\n  'cellpadding': 'cellPadding',\n  'cellspacing': 'cellSpacing',\n  'charset': 'charSet',\n  'class': 'className',\n  'classid': 'classId',\n  'colspan': 'colSpan',\n  'contenteditable': 'contentEditable',\n  'contextmenu': 'contextMenu',\n  'crossorigin': 'crossOrigin',\n  'enctype': 'encType',\n  'for': 'htmlFor',\n  'formaction': 'formAction',\n  'formenctype': 'formEncType',\n  'formmethod': 'formMethod',\n  'formnovalidate': 'formNoValidate',\n  'formtarget': 'formTarget',\n  'frameborder': 'frameBorder',\n  'hreflang': 'hrefLang',\n  'http-equiv': 'httpEquiv',\n  'inputmode': 'inputMode',\n  'keyparams': 'keyParams',\n  'keytype': 'keyType',\n  'marginheight': 'marginHeight',\n  'marginwidth': 'marginWidth',\n  'maxlength': 'maxLength',\n  'mediagroup': 'mediaGroup',\n  'minlength': 'minLength',\n  'novalidate': 'noValidate',\n  'radiogroup': 'radioGroup',\n  'readonly': 'readOnly',\n  'rowspan': 'rowSpan',\n  'spellcheck': 'spellCheck',\n  'srcdoc': 'srcDoc',\n  'srclang': 'srcLang',\n  'srcset': 'srcSet',\n  'tabindex': 'tabIndex',\n  'usemap': 'useMap'\n};\nvar getType = Object.prototype.toString;\n\nfunction extractDefinitionsFromASTTree(ast, parser) {\n  function reducer(aggregator, node) {\n    if (node.type === 'definition' || node.type === 'footnoteDefinition') {\n      aggregator.definitions[node.identifier] = node;\n\n      if (node.type === 'footnoteDefinition') {\n        if (node.children && node.children.length === 1 && node.children[0].type === 'paragraph') {\n          node.children[0].children.unshift({\n            type: 'textNode',\n            value: '[' + node.identifier + ']: '\n          });\n        }\n        /* package the prefix inside the first child */\n\n\n        aggregator.footnotes.push(_react2.default.createElement('div', {\n          key: node.identifier,\n          id: node.identifier\n        }, node.value || node.children.map(parser)));\n      }\n    }\n\n    return Array.isArray(node.children) ? node.children.reduce(reducer, aggregator) : aggregator;\n  }\n\n  ;\n  return [ast].reduce(reducer, {\n    definitions: {},\n    footnotes: []\n  });\n}\n\nfunction formExtraPropsForHTMLNodeType() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var ast = arguments[1];\n  var definitions = arguments[2];\n\n  switch (ast.type) {\n    case 'footnoteReference':\n      return _extends({}, props, {\n        href: '#' + ast.identifier\n      });\n\n    case 'image':\n      return _extends({}, props, {\n        title: ast.title,\n        alt: ast.alt,\n        src: ast.url\n      });\n\n    case 'imageReference':\n      return _extends({}, props, {\n        title: (0, _lodash2.default)(definitions, '[\\'' + ast.identifier + '\\'].title'),\n        alt: ast.alt,\n        src: (0, _lodash2.default)(definitions, '[\\'' + ast.identifier + '\\'].url')\n      });\n\n    case 'link':\n      return _extends({}, props, {\n        title: ast.title,\n        href: ast.url\n      });\n\n    case 'linkReference':\n      return _extends({}, props, {\n        title: (0, _lodash2.default)(definitions, '[\\'' + ast.identifier + '\\'].title'),\n        href: (0, _lodash2.default)(definitions, '[\\'' + ast.identifier + '\\'].url')\n      });\n\n    case 'list':\n      return _extends({}, props, {\n        start: ast.start\n      });\n\n    case 'tableCell':\n    case 'th':\n      return _extends({}, props, {\n        style: {\n          textAlign: ast.align\n        }\n      });\n  }\n\n  return props;\n}\n\nfunction getHTMLNodeTypeFromASTNodeType(node) {\n  switch (node.type) {\n    case 'break':\n      return 'br';\n\n    case 'delete':\n      return 'del';\n\n    case 'emphasis':\n      return 'em';\n\n    case 'footnoteReference':\n      return 'a';\n\n    case 'heading':\n      return 'h' + node.depth;\n\n    case 'image':\n    case 'imageReference':\n      return 'img';\n\n    case 'inlineCode':\n      return 'code';\n\n    case 'link':\n    case 'linkReference':\n      return 'a';\n\n    case 'list':\n      return node.ordered ? 'ol' : 'ul';\n\n    case 'listItem':\n      return 'li';\n\n    case 'paragraph':\n      return 'p';\n\n    case 'root':\n      return 'div';\n\n    case 'tableHeader':\n      return 'thead';\n\n    case 'tableRow':\n      return 'tr';\n\n    case 'tableCell':\n      return 'td';\n\n    case 'thematicBreak':\n      return 'hr';\n\n    case 'definition':\n    case 'footnoteDefinition':\n    case 'yaml':\n      return null;\n\n    default:\n      return node.type;\n  }\n}\n\nfunction seekCellsAndAlignThemIfNecessary(root, alignmentValues) {\n  var mapper = function mapper(child, index) {\n    if (child.type === 'tableCell') {\n      return _extends({}, child, {\n        align: alignmentValues[index]\n      });\n    } else if (Array.isArray(child.children) && child.children.length) {\n      return child.children.map(mapper);\n    }\n\n    return child;\n  };\n\n  if (Array.isArray(root.children) && root.children.length) {\n    root.children = root.children.map(mapper);\n  }\n\n  return root;\n}\n\nfunction attributeValueToJSXPropValue(key, value) {\n  if (key === 'style') {\n    return value.split(/;\\s?/).reduce(function (styles, kvPair) {\n      var key = kvPair.slice(0, kvPair.indexOf(':')); // snake-case to camelCase\n      // also handles PascalCasing vendor prefixes\n\n      var camelCasedKey = key.replace(/(\\-[a-z])/g, function (substr) {\n        return substr[1].toUpperCase();\n      }); // key.length + 1 to skip over the colon\n\n      styles[camelCasedKey] = kvPair.slice(key.length + 1).trim();\n      return styles;\n    }, {});\n  }\n\n  return value;\n}\n\nfunction coalesceInlineHTML(ast) {\n  function coalescer(node, index, siblings) {\n    if (node.type === 'html') {\n      // ignore block-level elements\n      if (BLOCK_ELEMENT_REGEX.test(node.value)) {\n        return;\n      } // ignore self-closing or non-content-bearing elements\n\n\n      if (SELF_CLOSING_ELEMENT_REGEX.test(node.value)) {\n        return;\n      } // are there more html nodes directly after? if so, fold them into the current node\n\n\n      if (index < siblings.length - 1 && siblings[index + 1].type === 'html') {\n        // create a new coalescer context\n        coalescer(siblings[index + 1], index + 1, siblings);\n      }\n\n      var i = index + 1;\n      var end = void 0; // where's the end tag?\n\n      while (end === undefined && i < siblings.length) {\n        if (siblings[i].type !== 'html') {\n          i += 1;\n          continue;\n        }\n\n        end = siblings[i];\n      }\n      /* all interim elements now become children of the current node, and we splice them (including end tag)\n         out of the sibling array so they will not be iterated-over by forEach */\n\n\n      node.children = siblings.slice(index + 1, i);\n      siblings.splice(index + 1, i - index);\n\n      var _node$value$match = node.value.match(HTML_EXTRACTOR_REGEX),\n          _node$value$match2 = _toArray(_node$value$match),\n          tag = _node$value$match2[0],\n          attributePairs = _node$value$match2.slice(1); // reassign the current node to whatever its tag is\n\n\n      node.type = tag.toLowerCase(); // make a best-effort conversion to JSX props\n\n      node.props = attributePairs.reduce(function (props, kvPair) {\n        var valueIndex = kvPair.indexOf('=');\n        var key = kvPair.slice(0, valueIndex === -1 ? undefined : valueIndex); // ignoring inline event handlers at this time - they pose enough of a security risk that they're\n        // not worth preserving; there's a reason React calls it \"dangerouslySetInnerHTML\"!\n\n        if (key.indexOf('on') !== 0) {\n          var value = kvPair.slice(key.length + 1); // strip the outermost single/double quote if it exists\n\n          if (value[0] === '\"' || value[0] === '\\'') {\n            value = value.slice(1, value.length - 1);\n          }\n\n          props[ATTRIBUTE_TO_JSX_PROP_MAP[key] || key] = attributeValueToJSXPropValue(key, value) || true;\n        }\n\n        return props;\n      }, {}); // null out .value or astToJSX() will set it as the child\n\n      node.value = null;\n    }\n\n    if (node.children) {\n      node.children.forEach(coalescer);\n    }\n  }\n\n  ;\n  return ast.children.forEach(coalescer);\n}\n\nfunction compiler(markdown) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$overrides = _ref.overrides,\n      overrides = _ref$overrides === undefined ? {} : _ref$overrides;\n\n  var definitions = void 0;\n  var footnotes = void 0;\n\n  function astToJSX(ast, index) {\n    /* `this` is the dictionary of definitions */\n    if (TEXT_AST_TYPES.indexOf(ast.type) !== -1) {\n      return ast.value;\n    }\n\n    var key = index || '0';\n\n    if (ast.type === 'code' && ast.value) {\n      var preProps = _extends({}, (0, _lodash2.default)(overrides, 'pre.props', {}), {\n        key: key\n      });\n\n      var langClassName = 'lang-' + ast.lang;\n      var codeBaseProps = (0, _lodash2.default)(overrides, 'code.props', {});\n\n      var codeProps = _extends({}, codeBaseProps, {\n        className: codeBaseProps.className ? codeBaseProps.className + ' ' + langClassName : langClassName\n      });\n\n      return _react2.default.createElement((0, _lodash2.default)(overrides, 'pre.component', 'pre'), preProps, _react2.default.createElement((0, _lodash2.default)(overrides, 'code.component', 'code'), codeProps, ast.value));\n    }\n    /* Refers to fenced blocks, need to create a pre:code nested structure */\n\n\n    if (ast.type === 'list' && ast.loose === false) {\n      ast.children = ast.children.map(function (item) {\n        if (item.children.length === 1 && item.children[0].type === 'paragraph') {\n          return _extends({}, item, {\n            children: item.children[0].children\n          });\n        }\n\n        return item;\n      });\n    }\n    /* tight list, remove the paragraph wrapper just inside the listItem */\n\n\n    if (ast.type === 'listItem') {\n      if (ast.checked === true || ast.checked === false) {\n        var liProps = _extends({}, (0, _lodash2.default)(overrides, 'li.props', {}), {\n          key: key\n        });\n\n        var inputProps = _extends({}, (0, _lodash2.default)(overrides, 'input.props', {}), {\n          key: 'checkbox',\n          type: 'checkbox',\n          checked: ast.checked,\n          readOnly: true\n        });\n\n        return _react2.default.createElement((0, _lodash2.default)(overrides, 'li.component', 'li'), liProps, [_react2.default.createElement((0, _lodash2.default)(overrides, 'input.component', 'input'), inputProps), ast.children.map(astToJSX)]);\n      }\n      /* gfm task list, need to add a checkbox */\n\n    }\n\n    if (ast.type === 'html') {\n      return _react2.default.createElement('div', {\n        key: key,\n        dangerouslySetInnerHTML: {\n          __html: ast.value\n        }\n      });\n    }\n    /* arbitrary HTML, do the gross thing for now */\n\n\n    if (ast.type === 'table') {\n      var tbody = {\n        type: 'tbody',\n        children: []\n      };\n      ast.children = ast.children.reduce(function (children, child, index) {\n        if (index === 0) {\n          /* manually marking the first row as tableHeader since that was removed in remark@4.x; it's important semantically. */\n          child.type = 'tableHeader';\n          children.unshift(seekCellsAndAlignThemIfNecessary(child, ast.align));\n        } else if (child.type === 'tableRow') {\n          tbody.children.push(seekCellsAndAlignThemIfNecessary(child, ast.align));\n        } else if (child.type === 'tableFooter') {\n          children.push(seekCellsAndAlignThemIfNecessary(child, ast.align));\n        }\n\n        return children;\n      }, [tbody]);\n    }\n    /* React yells if things aren't in the proper structure, so need to\n      delve into the immediate children and wrap tablerow(s) in a tbody */\n\n\n    if (ast.type === 'tableFooter') {\n      ast.children = [{\n        type: 'tr',\n        children: ast.children\n      }];\n    }\n    /* React yells if things aren't in the proper structure, so need to\n      delve into the immediate children and wrap the cells in a tablerow */\n\n\n    if (ast.type === 'tableHeader') {\n      ast.children = [{\n        type: 'tr',\n        children: ast.children.map(function (child) {\n          if (child.type === 'tableCell') {\n            child.type = 'th';\n          }\n          /* et voila, a proper table header */\n\n\n          return child;\n        })\n      }];\n    }\n    /* React yells if things aren't in the proper structure, so need to\n      delve into the immediate children and wrap the cells in a tablerow */\n\n\n    if (ast.type === 'footnoteReference') {\n      ast.children = [{\n        type: 'sup',\n        value: ast.identifier\n      }];\n    }\n    /* place the identifier inside a superscript tag for the link */\n\n\n    var htmlNodeType = getHTMLNodeTypeFromASTNodeType(ast);\n\n    if (htmlNodeType === null) {\n      return null;\n    }\n    /* bail out, not convertable to any HTML representation */\n\n\n    var props = _extends({\n      key: key\n    }, ast.props);\n\n    var override = overrides[htmlNodeType];\n\n    if (override) {\n      if (override.component) {\n        htmlNodeType = override.component;\n      }\n      /* sub out the normal html tag name for the JSX / ReactFactory\n         passed in by the caller */\n\n\n      if (override.props) {\n        props = _extends({}, override.props, props);\n      }\n      /* apply the prop overrides beneath the minimal set that are necessary\n         to have the markdown conversion work as expected */\n\n    }\n    /* their props + our props, with any duplicate keys overwritten by us\n       (necessary evil, file an issue if something comes up that needs\n       extra attention, only props specified in `formExtraPropsForHTMLNodeType`\n       will be overwritten on a key collision) */\n\n\n    var finalProps = formExtraPropsForHTMLNodeType(props, ast, definitions);\n\n    if (ast.children && ast.children.length === 1) {\n      if (TEXT_AST_TYPES.indexOf(ast.children[0].type) !== -1) {\n        ast.children = ast.children[0].value;\n      }\n    }\n    /* solitary text children don't need full parsing or React will add a wrapper */\n\n\n    var children = Array.isArray(ast.children) ? ast.children.map(astToJSX) : ast.children;\n    return _react2.default.createElement(htmlNodeType, finalProps, ast.value || children);\n  }\n\n  if (typeof markdown !== 'string') {\n    throw new Error('markdown-to-jsx: the first argument must be\\n                         a string');\n  }\n\n  if (getType.call(overrides) !== '[object Object]') {\n    throw new Error('markdown-to-jsx: options.overrides (second argument property) must be\\n                         undefined or an object literal with shape:\\n                         {\\n                            htmltagname: {\\n                                component: string|ReactComponent(optional),\\n                                props: object(optional)\\n                            }\\n                         }');\n  }\n\n  var remarkAST = (0, _unified2.default)().data('settings', {\n    footnotes: true,\n    gfm: true,\n    position: false\n  }).use(_remarkParse2.default).parse(markdown);\n  var extracted = extractDefinitionsFromASTTree(remarkAST, astToJSX);\n  definitions = extracted.definitions;\n  footnotes = extracted.footnotes;\n  coalesceInlineHTML(remarkAST);\n  var jsx = astToJSX(remarkAST); // discard the root <div> node if there is only one valid initial child\n  // generally this is a paragraph\n\n  if (jsx.props.children.length === 1) {\n    jsx = jsx.props.children[0];\n  }\n\n  if (footnotes.length) {\n    jsx.props.children.push(_react2.default.createElement('footer', {\n      key: 'footnotes'\n    }, footnotes));\n  }\n\n  return jsx;\n}\n\n;\n/**\n * A simple HOC for easy React use. Feed the markdown content as a direct child\n * and the rest is taken care of automatically.\n *\n * @param  {String}   options.children   must be a string\n * @param  {Object}   options.options    markdown-to-jsx options (arg 2 of the compiler)\n *\n * @return {ReactElement} the compiled JSX\n */\n\nvar Component = function Component(_ref2) {\n  var children = _ref2.children,\n      options = _ref2.options,\n      props = _objectWithoutProperties(_ref2, ['children', 'options']);\n\n  return compiler(children, options);\n};\n\nComponent.propTypes = {\n  children: _propTypes2.default.string.isRequired,\n  options: _propTypes2.default.object\n};\nexports.default = Component;","map":null,"metadata":{},"sourceType":"script"}